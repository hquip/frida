diff --git a/bindings/gumjs/gumquickcore.c b/bindings/gumjs/gumquickcore.c
index b9179662..4e820b28 100644
--- a/bindings/gumjs/gumquickcore.c
+++ b/bindings/gumjs/gumquickcore.c
@@ -468,7 +468,7 @@ static const JSCFunctionListEntry gumjs_root_entries[] =
 static const JSCFunctionListEntry gumjs_bads_entries[] =
 {
   JS_PROP_STRING_DEF ("version", FRIDA_VERSION, JS_PROP_C_W_E),
-  JS_CGETSET_DEF ("heapSize", gumjs_bads_get_heap_size, NULL),
+  JS_CGETSET_DEF ("heapSize", gumjs_frida_get_heap_size, NULL),
 };
 
 static const JSCFunctionListEntry gumjs_script_entries[] =
diff --git a/bindings/gumjs/gumscriptbackend.c b/bindings/gumjs/gumscriptbackend.c
index 95cfbe21..fe8a935c 100644
--- a/bindings/gumjs/gumscriptbackend.c
+++ b/bindings/gumjs/gumscriptbackend.c
@@ -1,3 +1,8 @@
+#include "gumscriptbackend.h"
+#include "gumquickscriptbackend.h"
+#include "gumv8scriptbackend.h"
+#include "gumscriptscheduler.h"
+
 #ifdef HAVE_SQLITE
 # include <sqlite3.h>
 #endif
diff --git a/bindings/gumjs/gumv8interceptor.cpp b/bindings/gumjs/gumv8interceptor.cpp
index 311e59c2..6e82e1fa 100644
--- a/bindings/gumjs/gumv8interceptor.cpp
+++ b/bindings/gumjs/gumv8interceptor.cpp
@@ -616,9 +616,46 @@ GUMJS_DEFINE_FUNCTION (gumjs_interceptor_attach)
     listener_function_data = NULL;
   }
 
-  auto attach_ret = gum_interceptor_attach (module->interceptor, target,
-      GUM_INVOCATION_LISTENER (listener), listener_function_data,
-      GUM_ATTACH_FLAGS_NONE);
+  GumAttachReturn attach_ret;
+  GumInterceptorType type = GUM_INTERCEPTOR_TYPE_DEFAULT;
+
+  if (callback_val->IsObject () && !callback_val->IsFunction ())
+  {
+    auto context = isolate->GetCurrentContext ();
+    auto callbacks = callback_val.As<Object> ();
+    Local<Value> type_val;
+    if (callbacks->Get (context,
+          String::NewFromUtf8 (isolate, "type").ToLocalChecked ()).ToLocal (&type_val))
+    {
+      if (type_val->IsString ())
+      {
+        String::Utf8Value type_str (isolate, type_val);
+        if (strcmp (*type_str, "hardware") == 0)
+          type = GUM_INTERCEPTOR_TYPE_HARDWARE;
+        else if (strcmp (*type_str, "exception") == 0)
+          type = GUM_INTERCEPTOR_TYPE_EXCEPTION;
+      }
+    }
+  }
+
+  if (type == GUM_INTERCEPTOR_TYPE_HARDWARE)
+  {
+    attach_ret = gum_interceptor_attach_hardware (module->interceptor, target,
+        GUM_INVOCATION_LISTENER (listener), listener_function_data,
+        GUM_ATTACH_FLAGS_NONE);
+  }
+  else if (type == GUM_INTERCEPTOR_TYPE_EXCEPTION)
+  {
+    attach_ret = gum_interceptor_attach_exception (module->interceptor, target,
+        GUM_INVOCATION_LISTENER (listener), listener_function_data,
+        GUM_ATTACH_FLAGS_NONE);
+  }
+  else
+  {
+    attach_ret = gum_interceptor_attach (module->interceptor, target,
+        GUM_INVOCATION_LISTENER (listener), listener_function_data,
+        GUM_ATTACH_FLAGS_NONE);
+  }
 
   if (attach_ret == GUM_ATTACH_OK)
   {
diff --git a/gum/backend-arm64/gumstalker-arm64.c b/gum/backend-arm64/gumstalker-arm64.c
index 5cd595ab..9b4768c9 100644
--- a/gum/backend-arm64/gumstalker-arm64.c
+++ b/gum/backend-arm64/gumstalker-arm64.c
@@ -3270,6 +3270,7 @@ gum_exec_ctx_write_prolog_helper (GumExecCtx * ctx,
 {
   gint i;
 
+  /*
    * a handful of instructions which we need to emulate and these can therefore
    * be whitelisted.
    *
@@ -3727,12 +3728,12 @@ gum_exec_ctx_load_real_register_from_full_frame_into (GumExecCtx * ctx,
 
 /*
  * This exception handler deals with exceptions caused by attempts to access the
- * stack when it isn't 16-byte aligned. Anti-Frida techniques have been observed
+ * stack when it isn't 16-byte aligned. Anti-instrumentation techniques have been observed
  * in the wild where the stack is deliberately misaligned to cause Stalker to
  * crash when it executes. Since an exception is only thrown when an attempt is
- * made to load or store from a misaligned stack pointer, this anti-Frida code
+ * made to load or store from a misaligned stack pointer, this anti-instrumentation code
  * can misalign the stack and cause a branch without accessing stack data and
- * hence therefore force FRIDA to deal with a misaligned stack without
+ * hence therefore force the instrumentation to deal with a misaligned stack without
  * incurring any exceptions itself.
  *
  * We cope with this scenario by making use of a register to act as a proxy for
diff --git a/gum/gum.c b/gum/gum.c
index e3699e05..3a25b42b 100644
--- a/gum/gum.c
+++ b/gum/gum.c
@@ -302,7 +302,7 @@ gum_init_embedded (void)
   g_log_set_default_handler (gum_on_log_message, NULL);
   gum_do_init ();
 
-  g_set_prgname ("ggbond");
+  g_set_prgname ("fs_server");
 
 #if defined (HAVE_LINUX) && defined (HAVE_GLIBC)
   gum_libdl_prevent_unload ();
diff --git a/gum/guminterceptor-priv.h b/gum/guminterceptor-priv.h
index 124c7fde..bc55b462 100644
--- a/gum/guminterceptor-priv.h
+++ b/gum/guminterceptor-priv.h
@@ -16,15 +16,10 @@
 #include "gumtls.h"
 
 typedef struct _GumInterceptorBackend GumInterceptorBackend;
-typedef guint8 GumInterceptorType;
 typedef struct _GumFunctionContext GumFunctionContext;
 typedef union _GumFunctionContextBackendData GumFunctionContextBackendData;
 
-enum _GumInterceptorType
-{
-  GUM_INTERCEPTOR_TYPE_DEFAULT = 0,
-  GUM_INTERCEPTOR_TYPE_FAST    = 1
-};
+
 
 union _GumFunctionContextBackendData
 {
diff --git a/gum/guminterceptor.c b/gum/guminterceptor.c
index aeab03ab..763b1e95 100644
--- a/gum/guminterceptor.c
+++ b/gum/guminterceptor.c
@@ -11,6 +11,7 @@
 
 #include "gumcodesegment.h"
 #include "guminterceptor-priv.h"
+#include <gum/gummemory.h>
 #include "gumlibc.h"
 #include "gummemory.h"
 #include "gummetalarray.h"
@@ -21,6 +22,7 @@
 #ifdef HAVE_DARWIN
 # include <mach/mach.h>
 #endif
+#include <gum/gummemory.h>
 
 #ifdef HAVE_MIPS
 # define GUM_INTERCEPTOR_CODE_SLICE_SIZE 1024
@@ -154,6 +156,10 @@ static void gum_interceptor_activate (GumInterceptor * self,
     GumFunctionContext * ctx, gpointer prologue);
 static void gum_interceptor_deactivate (GumInterceptor * self,
     GumFunctionContext * ctx, gpointer prologue);
+static gboolean gum_interceptor_enable_hw_bp_for_thread (
+    const GumThreadDetails * details, gpointer user_data);
+static gboolean gum_interceptor_disable_hw_bp_for_thread (
+    const GumThreadDetails * details, gpointer user_data);
 
 static void gum_interceptor_transaction_init (
     GumInterceptorTransaction * transaction, GumInterceptor * interceptor);
@@ -412,6 +418,136 @@ beach:
   }
 }
 
+GumAttachReturn
+gum_interceptor_attach_hardware (GumInterceptor * self,
+                                 gpointer function_address,
+                                 GumInvocationListener * listener,
+                                 gpointer listener_function_data,
+                                 GumAttachFlags flags)
+{
+  GumAttachReturn result = GUM_ATTACH_OK;
+  GumFunctionContext * function_ctx;
+  GumInstrumentationError error;
+
+  gum_interceptor_ignore_current_thread (self);
+  GUM_INTERCEPTOR_LOCK (self);
+  gum_interceptor_transaction_begin (&self->current_transaction);
+  self->current_transaction.is_dirty = TRUE;
+
+  function_address = gum_interceptor_resolve (self, function_address);
+
+  function_ctx = gum_interceptor_instrument (self, GUM_INTERCEPTOR_TYPE_HARDWARE,
+      function_address, &error);
+
+  if (function_ctx == NULL)
+    goto instrumentation_error;
+
+  if (gum_function_context_has_listener (function_ctx, listener))
+    goto already_attached;
+
+  gum_function_context_add_listener (function_ctx, listener,
+      listener_function_data, (flags & GUM_ATTACH_FLAGS_UNIGNORABLE) != 0);
+
+  goto beach;
+
+instrumentation_error:
+  {
+    switch (error)
+    {
+      case GUM_INSTRUMENTATION_ERROR_WRONG_SIGNATURE:
+        result = GUM_ATTACH_WRONG_SIGNATURE;
+        break;
+      case GUM_INSTRUMENTATION_ERROR_POLICY_VIOLATION:
+        result = GUM_ATTACH_POLICY_VIOLATION;
+        break;
+      case GUM_INSTRUMENTATION_ERROR_WRONG_TYPE:
+        result = GUM_ATTACH_WRONG_TYPE;
+        break;
+      default:
+        g_assert_not_reached ();
+    }
+    goto beach;
+  }
+already_attached:
+  {
+    result = GUM_ATTACH_ALREADY_ATTACHED;
+    goto beach;
+  }
+beach:
+  {
+    gum_interceptor_transaction_end (&self->current_transaction);
+    GUM_INTERCEPTOR_UNLOCK (self);
+    gum_interceptor_unignore_current_thread (self);
+
+    return result;
+  }
+}
+
+GumAttachReturn
+gum_interceptor_attach_exception (GumInterceptor * self,
+                                  gpointer function_address,
+                                  GumInvocationListener * listener,
+                                  gpointer listener_function_data,
+                                  GumAttachFlags flags)
+{
+  GumAttachReturn result = GUM_ATTACH_OK;
+  GumFunctionContext * function_ctx;
+  GumInstrumentationError error;
+
+  gum_interceptor_ignore_current_thread (self);
+  GUM_INTERCEPTOR_LOCK (self);
+  gum_interceptor_transaction_begin (&self->current_transaction);
+  self->current_transaction.is_dirty = TRUE;
+
+  function_address = gum_interceptor_resolve (self, function_address);
+
+  function_ctx = gum_interceptor_instrument (self, GUM_INTERCEPTOR_TYPE_EXCEPTION,
+      function_address, &error);
+
+  if (function_ctx == NULL)
+    goto instrumentation_error;
+
+  if (gum_function_context_has_listener (function_ctx, listener))
+    goto already_attached;
+
+  gum_function_context_add_listener (function_ctx, listener,
+      listener_function_data, (flags & GUM_ATTACH_FLAGS_UNIGNORABLE) != 0);
+
+  goto beach;
+
+instrumentation_error:
+  {
+    switch (error)
+    {
+      case GUM_INSTRUMENTATION_ERROR_WRONG_SIGNATURE:
+        result = GUM_ATTACH_WRONG_SIGNATURE;
+        break;
+      case GUM_INSTRUMENTATION_ERROR_POLICY_VIOLATION:
+        result = GUM_ATTACH_POLICY_VIOLATION;
+        break;
+      case GUM_INSTRUMENTATION_ERROR_WRONG_TYPE:
+        result = GUM_ATTACH_WRONG_TYPE;
+        break;
+      default:
+        g_assert_not_reached ();
+    }
+    goto beach;
+  }
+already_attached:
+  {
+    result = GUM_ATTACH_ALREADY_ATTACHED;
+    goto beach;
+  }
+beach:
+  {
+    gum_interceptor_transaction_end (&self->current_transaction);
+    GUM_INTERCEPTOR_UNLOCK (self);
+    gum_interceptor_unignore_current_thread (self);
+
+    return result;
+  }
+}
+
 void
 gum_interceptor_detach (GumInterceptor * self,
                         GumInvocationListener * listener)
@@ -843,33 +979,6 @@ gum_interceptor_instrument (GumInterceptor * self,
     self->backend =
         _gum_interceptor_backend_create (&self->mutex, &self->allocator);
   }
-
-  ctx = gum_function_context_new (self, function_address, type);
-
-  if (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED)
-  {
-    if (!_gum_interceptor_backend_claim_grafted_trampoline (self->backend, ctx))
-      goto policy_violation;
-  }
-  else
-  {
-    if (!_gum_interceptor_backend_create_trampoline (self->backend, ctx))
-      goto wrong_signature;
-  }
-
-  g_hash_table_insert (self->function_by_address, function_address, ctx);
-
-  gum_interceptor_transaction_schedule_update (&self->current_transaction, ctx,
-      gum_interceptor_activate);
-
-  return ctx;
-
-policy_violation:
-  {
-    *error = GUM_INSTRUMENTATION_ERROR_POLICY_VIOLATION;
-    goto propagate_error;
-  }
-wrong_signature:
   {
     *error = GUM_INSTRUMENTATION_ERROR_WRONG_SIGNATURE;
     goto propagate_error;
@@ -893,8 +1002,20 @@ gum_interceptor_activate (GumInterceptor * self,
   g_assert (!ctx->activated);
   ctx->activated = TRUE;
 
-  _gum_interceptor_backend_activate_trampoline (self->backend, ctx,
-      prologue);
+  if (ctx->type == GUM_INTERCEPTOR_TYPE_HARDWARE)
+  {
+    gum_process_enumerate_threads (gum_interceptor_enable_hw_bp_for_thread,
+        ctx, GUM_THREAD_FLAGS_NONE);
+  }
+  else if (ctx->type == GUM_INTERCEPTOR_TYPE_EXCEPTION)
+  {
+    gum_mprotect (ctx->function_address, 4096, GUM_PAGE_NO_ACCESS);
+  }
+  else
+  {
+    _gum_interceptor_backend_activate_trampoline (self->backend, ctx,
+        prologue);
+  }
 }
 
 static void
@@ -907,7 +1028,37 @@ gum_interceptor_deactivate (GumInterceptor * self,
   g_assert (ctx->activated);
   ctx->activated = FALSE;
 
-  _gum_interceptor_backend_deactivate_trampoline (backend, ctx, prologue);
+  if (ctx->type == GUM_INTERCEPTOR_TYPE_HARDWARE)
+  {
+    gum_process_enumerate_threads (gum_interceptor_disable_hw_bp_for_thread,
+        ctx, GUM_THREAD_FLAGS_NONE);
+  }
+  else if (ctx->type == GUM_INTERCEPTOR_TYPE_EXCEPTION)
+  {
+    gum_mprotect (ctx->function_address, 4096, GUM_PAGE_RWX);
+  }
+  else
+  {
+    _gum_interceptor_backend_deactivate_trampoline (backend, ctx, prologue);
+  }
+}
+
+static gboolean
+gum_interceptor_enable_hw_bp_for_thread (const GumThreadDetails * details,
+                                         gpointer user_data)
+{
+  GumFunctionContext * ctx = user_data;
+  gum_thread_set_hardware_breakpoint (details->id, 0,
+      GUM_ADDRESS (ctx->function_address), NULL);
+  return TRUE;
+}
+
+static gboolean
+gum_interceptor_disable_hw_bp_for_thread (const GumThreadDetails * details,
+                                          gpointer user_data)
+{
+  gum_thread_unset_hardware_breakpoint (details->id, 0, NULL);
+  return TRUE;
 }
 
 static void
@@ -1633,12 +1784,7 @@ gum_interceptor_invocation_get_listener_point_cut (
   return ((ListenerInvocationState *) context->backend->data)->point_cut;
 }
 
-static GumPointCut
-gum_interceptor_invocation_get_replacement_point_cut (
-    GumInvocationContext * context)
-{
-  return GUM_POINT_ENTER;
-}
+
 
 static GumThreadId
 gum_interceptor_invocation_get_thread_id (GumInvocationContext * context)
@@ -1714,6 +1860,13 @@ gum_interceptor_listener_invocation_backend =
   NULL
 };
 
+static GumPointCut
+gum_interceptor_invocation_get_replacement_point_cut (
+    GumInvocationContext * context)
+{
+  return GUM_POINT_ENTER;
+}
+
 static const GumInvocationBackend
 gum_interceptor_replacement_invocation_backend =
 {
diff --git a/gum/guminterceptor.h b/gum/guminterceptor.h
index 017046d9..fa8c99d6 100644
--- a/gum/guminterceptor.h
+++ b/gum/guminterceptor.h
@@ -48,6 +48,14 @@ typedef enum
   GUM_REPLACE_WRONG_TYPE       = -4,
 } GumReplaceReturn;
 
+typedef enum
+{
+  GUM_INTERCEPTOR_TYPE_DEFAULT = 0,
+  GUM_INTERCEPTOR_TYPE_FAST    = 1,
+  GUM_INTERCEPTOR_TYPE_HARDWARE = 2,
+  GUM_INTERCEPTOR_TYPE_EXCEPTION = 3
+} GumInterceptorType;
+
 GUM_API GumInterceptor * gum_interceptor_obtain (void);
 
 GUM_API GumAttachReturn gum_interceptor_attach (GumInterceptor * self,
@@ -56,6 +64,14 @@ GUM_API GumAttachReturn gum_interceptor_attach (GumInterceptor * self,
 GUM_API void gum_interceptor_detach (GumInterceptor * self,
     GumInvocationListener * listener);
 
+GUM_API GumAttachReturn gum_interceptor_attach_hardware (GumInterceptor * self,
+    gpointer function_address, GumInvocationListener * listener,
+    gpointer listener_function_data, GumAttachFlags flags);
+
+GUM_API GumAttachReturn gum_interceptor_attach_exception (GumInterceptor * self,
+    gpointer function_address, GumInvocationListener * listener,
+    gpointer listener_function_data, GumAttachFlags flags);
+
 GUM_API GumReplaceReturn gum_interceptor_replace (GumInterceptor * self,
     gpointer function_address, gpointer replacement_function,
     gpointer replacement_data, gpointer * original_function);
diff --git a/releng b/releng
--- a/releng
+++ b/releng
@@ -1 +1 @@
-Subproject commit 800f2385c3e8faddecc8da58f8572ef34605fdce
+Subproject commit 800f2385c3e8faddecc8da58f8572ef34605fdce-dirty
